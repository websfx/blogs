# 变量名存放在哪里？

这是一个非常有意思的话题，之前在网上看到有人问道这个问题，比如说在PHP里面我们写下 ```$name = "名字"``` 这样的代码语句，了解了变量在内存中存储方式的人会知道，变量的值在存放在栈内存里面的，但是名字呢？

针对这个问题，咱们先要区分一下编译型语言和解释型语言，这2种语言运行方式完全不一样，C/C++是典型的编译型语言，C几乎是所有解释型语言的之父，比如常见的JS，PHP，Python。

编译型语言要想运行，必须使用一个编译器去把代码转换成目标平台机器代码。而且解释型语言是通过一个解释器实时翻译成一种中间代码一行行运行。所以，前者又被称为静态语言，而后者又被称为动态语言。还有像Java，C#则属于这2种中间，因为他们有一个预编译的过程，会先把代码转换成中间代码，在Java里面就叫字节码，然后在虚拟机（jvm）里面执行，效率比纯解释执行高。

举个例子，像PHP这样的动态语言在执行的时候会被翻译成opcode后一行行执行，由于PHP的解释器是C写的，本质上还是调用C的API。C是静态编译型语言，不同平台都得安装相应平台的版本的解释器，x86的和ARM的肯定不一样，Linux和Windows的也不一样。

说这么多，我想说明一个问题，那就是变量名和变量在这2种语言里面的存储是有区别的，咱就先说说经典的C语言：

---

## C语言里面变量和变量名的存储

为了说明这个问题，咱们简单的来说一下C里面变量在内存里面的存储：

1.栈区（stack）— 由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。

2.堆区（heap） — 一般由程序员分配释放， 用来存储数组，结构体，对象等。若程序员不释放，程序结束时可能由OS回收。

3.全局区（静态区）（static）— 存放全局变量、静态数据、常量。程序结束后由系统释放。

4.文字常量区 — 常量字符串就是放在这里的。 程序结束后由系统释放。

5.程序代码区 — 存放函数体（类成员函数和全局函数）的二进制代码。

![栈堆](http://ww1.sinaimg.cn/mw690/5f6e3e27ly1fxehedktbwj20u70fn75i.jpg)

值得一说的是，栈内存是有大小限制的，比如默认情况下，Linux平台的是8MB，如果超过这个限制，就会出现 **stackoverflow**，而堆内存并无限制，内存有多大就可以申请多大。

看完上面的说明，我们可以得出一个结论: 全局变量存放在全局区，在程序一开始就分配好了，而且局部变量在存放在栈区。

但是这好像并没有说明变量名在哪里吧？比如下面这段C代码,a, b到底存在哪里？：

```C
#include <stdio.h>

int a = 1; //全局初始化区

int main(int argc, char const *argv[])
{
    int b; //栈
    b = a + 5;
    printf("%d\n", b);
    return 0;
}
```

为了搞明白这个问题，我们需要了解一下汇编, 使用gdb查看汇编代码：

```AS
   (gdb) disass main
Dump of assembler code for function main:
   0x0000000000400526 <+0>:	push   %rbp
   0x0000000000400527 <+1>:	mov    %rsp,%rbp
   0x000000000040052a <+4>:	sub    $0x20,%rsp
   0x000000000040052e <+8>:	mov    %edi,-0x14(%rbp)
   0x0000000000400531 <+11>:	mov    %rsi,-0x20(%rbp)
   0x0000000000400535 <+15>:	mov    0x200afd(%rip),%eax        # 0x601038 <a>
   0x000000000040053b <+21>:	add    $0x5,%eax
   0x000000000040053e <+24>:	mov    %eax,-0x4(%rbp)
   0x0000000000400541 <+27>:	mov    -0x4(%rbp),%eax
   0x0000000000400544 <+30>:	mov    %eax,%esi
   0x0000000000400546 <+32>:	mov    $0x4005e4,%edi
   0x000000000040054b <+37>:	mov    $0x0,%eax
   0x0000000000400550 <+42>:	callq  0x400400 <printf@plt>
=> 0x0000000000400555 <+47>:	mov    $0x0,%eax
   0x000000000040055a <+52>:	leaveq 
   0x000000000040055b <+53>:	retq   
End of assembler dump.
```

虽然上面这个很难读懂，但是应该能看到在这一大堆汇编指令执行的背后，并没有变量名这个东西，所有的变量名到最后都变成了内存地址，汇编指令操作的是各种寄存器和内存地址。

>定义int a;时,编译器分配4个字节内存,并命名该4个字节的空间名字为a(即变量名),当用到变量名a时,就是在使用那4个字节的内存空间。 5是一个常数,在程序编译时存放在代码的常量区存放着它的值(就是5),当执行a=5时,程序将5这个常量拷贝到a所在的4个字节空间中,就完成了赋值操作.a是我们对那个整形变量的4个字节取的"名字",是我们人为给的,实际上计算机并不存储a这个名字,只是我们编程时给那4个字节内存取个名字好用。实际上程序在编译时,所有的a都转换为了那个地址空间了,编译成机器代码后,没有a这个说法了。a这个名字只存在于我们编写的代码中.5不是被随机分配的,而总是位于程序的数据段中,可能在不同的机器上在数据段中的位置可能不一致,它的地址其实不能以我们常用到的内存地址来理解,因为牵扯到一个叫"计算机寻址方式"的问题。

以上的内容有参考网上很多文章，仅供参考！
